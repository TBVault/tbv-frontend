/**
 * Generated by orval v7.17.0 ðŸº
 * Do not edit manually.
 * The Bhakti Vault API
 * FastAPI application with OpenID Connect authentication
 * OpenAPI spec version: 1.0.0
 */
import type {
  HTTPValidationError,
  HelloDto,
  LoginResponse,
  PublicHelloWorldPydanticPublicHelloWorldPydanticGetParams,
  Transcript,
  TranscriptTranscriptGetParams,
  TranscriptsPaginated,
  TranscriptsTranscriptsGetParams,
  User
} from '../../schemas';

import { customFetch } from '../../../customFetch';

/**
 * Root endpoint
 * @summary Root
 */
export type rootGetResponse200 = {
  data: unknown
  status: 200
}
    
export type rootGetResponseSuccess = (rootGetResponse200) & {
  headers: Headers;
};
;

export type rootGetResponse = (rootGetResponseSuccess)

export const getRootGetUrl = () => {


  

  return `/`
}

export const rootGet = async ( options?: RequestInit): Promise<rootGetResponse> => {
  
  return customFetch<rootGetResponse>(getRootGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * Health check endpoint
 * @summary Health
 */
export type healthHealthGetResponse200 = {
  data: unknown
  status: 200
}
    
export type healthHealthGetResponseSuccess = (healthHealthGetResponse200) & {
  headers: Headers;
};
;

export type healthHealthGetResponse = (healthHealthGetResponseSuccess)

export const getHealthHealthGetUrl = () => {


  

  return `/health`
}

export const healthHealthGet = async ( options?: RequestInit): Promise<healthHealthGetResponse> => {
  
  return customFetch<healthHealthGetResponse>(getHealthHealthGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * @summary Public Hello World Pydantic
 */
export type publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse200 = {
  data: HelloDto
  status: 200
}

export type publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type publicHelloWorldPydanticPublicHelloWorldPydanticGetResponseSuccess = (publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse200) & {
  headers: Headers;
};
export type publicHelloWorldPydanticPublicHelloWorldPydanticGetResponseError = (publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse422) & {
  headers: Headers;
};

export type publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse = (publicHelloWorldPydanticPublicHelloWorldPydanticGetResponseSuccess | publicHelloWorldPydanticPublicHelloWorldPydanticGetResponseError)

export const getPublicHelloWorldPydanticPublicHelloWorldPydanticGetUrl = (params: PublicHelloWorldPydanticPublicHelloWorldPydanticGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/public/hello_world_pydantic?${stringifiedParams}` : `/public/hello_world_pydantic`
}

export const publicHelloWorldPydanticPublicHelloWorldPydanticGet = async (params: PublicHelloWorldPydanticPublicHelloWorldPydanticGetParams, options?: RequestInit): Promise<publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse> => {
  
  return customFetch<publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse>(getPublicHelloWorldPydanticPublicHelloWorldPydanticGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * @summary Transcript
 */
export type transcriptTranscriptGetResponse200 = {
  data: Transcript
  status: 200
}

export type transcriptTranscriptGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type transcriptTranscriptGetResponseSuccess = (transcriptTranscriptGetResponse200) & {
  headers: Headers;
};
export type transcriptTranscriptGetResponseError = (transcriptTranscriptGetResponse422) & {
  headers: Headers;
};

export type transcriptTranscriptGetResponse = (transcriptTranscriptGetResponseSuccess | transcriptTranscriptGetResponseError)

export const getTranscriptTranscriptGetUrl = (params: TranscriptTranscriptGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/transcript?${stringifiedParams}` : `/transcript`
}

export const transcriptTranscriptGet = async (params: TranscriptTranscriptGetParams, options?: RequestInit): Promise<transcriptTranscriptGetResponse> => {
  
  return customFetch<transcriptTranscriptGetResponse>(getTranscriptTranscriptGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * @summary Transcripts
 */
export type transcriptsTranscriptsGetResponse200 = {
  data: TranscriptsPaginated
  status: 200
}

export type transcriptsTranscriptsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type transcriptsTranscriptsGetResponseSuccess = (transcriptsTranscriptsGetResponse200) & {
  headers: Headers;
};
export type transcriptsTranscriptsGetResponseError = (transcriptsTranscriptsGetResponse422) & {
  headers: Headers;
};

export type transcriptsTranscriptsGetResponse = (transcriptsTranscriptsGetResponseSuccess | transcriptsTranscriptsGetResponseError)

export const getTranscriptsTranscriptsGetUrl = (params: TranscriptsTranscriptsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/transcripts?${stringifiedParams}` : `/transcripts`
}

export const transcriptsTranscriptsGet = async (params: TranscriptsTranscriptsGetParams, options?: RequestInit): Promise<transcriptsTranscriptsGetResponse> => {
  
  return customFetch<transcriptsTranscriptsGetResponse>(getTranscriptsTranscriptsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * Protected hello world endpoint - requires valid OIDC JWT token.
Returns "helloworld" string.
 * @summary Protected Hello World
 */
export type protectedHelloWorldProtectedHelloworldGetResponse200 = {
  data: HelloDto
  status: 200
}
    
export type protectedHelloWorldProtectedHelloworldGetResponseSuccess = (protectedHelloWorldProtectedHelloworldGetResponse200) & {
  headers: Headers;
};
;

export type protectedHelloWorldProtectedHelloworldGetResponse = (protectedHelloWorldProtectedHelloworldGetResponseSuccess)

export const getProtectedHelloWorldProtectedHelloworldGetUrl = () => {


  

  return `/protected/helloworld`
}

export const protectedHelloWorldProtectedHelloworldGet = async ( options?: RequestInit): Promise<protectedHelloWorldProtectedHelloworldGetResponse> => {
  
  return customFetch<protectedHelloWorldProtectedHelloworldGetResponse>(getProtectedHelloWorldProtectedHelloworldGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * Login endpoint - validates OIDC JWT token and returns user information.
Send the Google OIDC token in the Authorization header as: Bearer <token>
 * @summary Login
 */
export type loginAuthLoginPostResponse200 = {
  data: LoginResponse
  status: 200
}
    
export type loginAuthLoginPostResponseSuccess = (loginAuthLoginPostResponse200) & {
  headers: Headers;
};
;

export type loginAuthLoginPostResponse = (loginAuthLoginPostResponseSuccess)

export const getLoginAuthLoginPostUrl = () => {


  

  return `/auth/login`
}

export const loginAuthLoginPost = async ( options?: RequestInit): Promise<loginAuthLoginPostResponse> => {
  
  return customFetch<loginAuthLoginPostResponse>(getLoginAuthLoginPostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}


/**
 * Get the current authenticated user's account information.
Requires a valid OIDC JWT token.
 * @summary Get Current Account
 */
export type getCurrentAccountAuthMeGetResponse200 = {
  data: User
  status: 200
}
    
export type getCurrentAccountAuthMeGetResponseSuccess = (getCurrentAccountAuthMeGetResponse200) & {
  headers: Headers;
};
;

export type getCurrentAccountAuthMeGetResponse = (getCurrentAccountAuthMeGetResponseSuccess)

export const getGetCurrentAccountAuthMeGetUrl = () => {


  

  return `/auth/me`
}

export const getCurrentAccountAuthMeGet = async ( options?: RequestInit): Promise<getCurrentAccountAuthMeGetResponse> => {
  
  return customFetch<getCurrentAccountAuthMeGetResponse>(getGetCurrentAccountAuthMeGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


