/**
 * Generated by orval v7.17.0 ðŸº
 * Do not edit manually.
 * The Bhakti Vault API
 * FastAPI application with OpenID Connect authentication
 * OpenAPI spec version: 1.0.0
 */
import type {
  HTTPValidationError,
  HelloDto,
  LoginResponse,
  PublicHelloWorldPydanticPublicHelloWorldPydanticGetParams,
  Transcript,
  TranscriptProtectedTranscriptGetParams,
  TranscriptsPaginated,
  TranscriptsProtectedTranscriptsGetParams,
  User
} from '../../schemas';

import { customFetch } from '../../../customFetch';

/**
 * Root endpoint
 * @summary Root
 */
export type rootGetResponse200 = {
  data: unknown
  status: 200
}
    
export type rootGetResponseSuccess = (rootGetResponse200) & {
  headers: Headers;
};
;

export type rootGetResponse = (rootGetResponseSuccess)

export const getRootGetUrl = () => {


  

  return `/`
}

export const rootGet = async ( options?: RequestInit): Promise<rootGetResponse> => {
  
  return customFetch<rootGetResponse>(getRootGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * Health check endpoint
 * @summary Health
 */
export type healthHealthGetResponse200 = {
  data: unknown
  status: 200
}
    
export type healthHealthGetResponseSuccess = (healthHealthGetResponse200) & {
  headers: Headers;
};
;

export type healthHealthGetResponse = (healthHealthGetResponseSuccess)

export const getHealthHealthGetUrl = () => {


  

  return `/health`
}

export const healthHealthGet = async ( options?: RequestInit): Promise<healthHealthGetResponse> => {
  
  return customFetch<healthHealthGetResponse>(getHealthHealthGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * @summary Public Hello World Pydantic
 */
export type publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse200 = {
  data: HelloDto
  status: 200
}

export type publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type publicHelloWorldPydanticPublicHelloWorldPydanticGetResponseSuccess = (publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse200) & {
  headers: Headers;
};
export type publicHelloWorldPydanticPublicHelloWorldPydanticGetResponseError = (publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse422) & {
  headers: Headers;
};

export type publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse = (publicHelloWorldPydanticPublicHelloWorldPydanticGetResponseSuccess | publicHelloWorldPydanticPublicHelloWorldPydanticGetResponseError)

export const getPublicHelloWorldPydanticPublicHelloWorldPydanticGetUrl = (params: PublicHelloWorldPydanticPublicHelloWorldPydanticGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/public/hello_world_pydantic?${stringifiedParams}` : `/public/hello_world_pydantic`
}

export const publicHelloWorldPydanticPublicHelloWorldPydanticGet = async (params: PublicHelloWorldPydanticPublicHelloWorldPydanticGetParams, options?: RequestInit): Promise<publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse> => {
  
  return customFetch<publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse>(getPublicHelloWorldPydanticPublicHelloWorldPydanticGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * Protected hello world endpoint - requires valid OIDC JWT token.
Returns "helloworld" string.
 * @summary Protected Hello World
 */
export type protectedHelloWorldProtectedHelloworldGetResponse200 = {
  data: HelloDto
  status: 200
}
    
export type protectedHelloWorldProtectedHelloworldGetResponseSuccess = (protectedHelloWorldProtectedHelloworldGetResponse200) & {
  headers: Headers;
};
;

export type protectedHelloWorldProtectedHelloworldGetResponse = (protectedHelloWorldProtectedHelloworldGetResponseSuccess)

export const getProtectedHelloWorldProtectedHelloworldGetUrl = () => {


  

  return `/protected/helloworld`
}

export const protectedHelloWorldProtectedHelloworldGet = async ( options?: RequestInit): Promise<protectedHelloWorldProtectedHelloworldGetResponse> => {
  
  return customFetch<protectedHelloWorldProtectedHelloworldGetResponse>(getProtectedHelloWorldProtectedHelloworldGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * @summary Transcript
 */
export type transcriptProtectedTranscriptGetResponse200 = {
  data: Transcript
  status: 200
}

export type transcriptProtectedTranscriptGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type transcriptProtectedTranscriptGetResponseSuccess = (transcriptProtectedTranscriptGetResponse200) & {
  headers: Headers;
};
export type transcriptProtectedTranscriptGetResponseError = (transcriptProtectedTranscriptGetResponse422) & {
  headers: Headers;
};

export type transcriptProtectedTranscriptGetResponse = (transcriptProtectedTranscriptGetResponseSuccess | transcriptProtectedTranscriptGetResponseError)

export const getTranscriptProtectedTranscriptGetUrl = (params: TranscriptProtectedTranscriptGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/protected/transcript?${stringifiedParams}` : `/protected/transcript`
}

export const transcriptProtectedTranscriptGet = async (params: TranscriptProtectedTranscriptGetParams, options?: RequestInit): Promise<transcriptProtectedTranscriptGetResponse> => {
  
  return customFetch<transcriptProtectedTranscriptGetResponse>(getTranscriptProtectedTranscriptGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * @summary Transcripts
 */
export type transcriptsProtectedTranscriptsGetResponse200 = {
  data: TranscriptsPaginated
  status: 200
}

export type transcriptsProtectedTranscriptsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type transcriptsProtectedTranscriptsGetResponseSuccess = (transcriptsProtectedTranscriptsGetResponse200) & {
  headers: Headers;
};
export type transcriptsProtectedTranscriptsGetResponseError = (transcriptsProtectedTranscriptsGetResponse422) & {
  headers: Headers;
};

export type transcriptsProtectedTranscriptsGetResponse = (transcriptsProtectedTranscriptsGetResponseSuccess | transcriptsProtectedTranscriptsGetResponseError)

export const getTranscriptsProtectedTranscriptsGetUrl = (params: TranscriptsProtectedTranscriptsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/protected/transcripts?${stringifiedParams}` : `/protected/transcripts`
}

export const transcriptsProtectedTranscriptsGet = async (params: TranscriptsProtectedTranscriptsGetParams, options?: RequestInit): Promise<transcriptsProtectedTranscriptsGetResponse> => {
  
  return customFetch<transcriptsProtectedTranscriptsGetResponse>(getTranscriptsProtectedTranscriptsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * Login endpoint - validates OIDC JWT token and returns user information.
Send the Google OIDC token in the Authorization header as: Bearer <token>
Returns a failed login response if the user doesn't exist in the database.
 * @summary Login
 */
export type loginAuthLoginPostResponse200 = {
  data: LoginResponse
  status: 200
}
    
export type loginAuthLoginPostResponseSuccess = (loginAuthLoginPostResponse200) & {
  headers: Headers;
};
;

export type loginAuthLoginPostResponse = (loginAuthLoginPostResponseSuccess)

export const getLoginAuthLoginPostUrl = () => {


  

  return `/auth/login`
}

export const loginAuthLoginPost = async ( options?: RequestInit): Promise<loginAuthLoginPostResponse> => {
  
  return customFetch<loginAuthLoginPostResponse>(getLoginAuthLoginPostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}


/**
 * Get the current authenticated user's account information.
Requires a valid OIDC JWT token.
 * @summary Get Current Account
 */
export type getCurrentAccountAuthMeGetResponse200 = {
  data: User
  status: 200
}
    
export type getCurrentAccountAuthMeGetResponseSuccess = (getCurrentAccountAuthMeGetResponse200) & {
  headers: Headers;
};
;

export type getCurrentAccountAuthMeGetResponse = (getCurrentAccountAuthMeGetResponseSuccess)

export const getGetCurrentAccountAuthMeGetUrl = () => {


  

  return `/auth/me`
}

export const getCurrentAccountAuthMeGet = async ( options?: RequestInit): Promise<getCurrentAccountAuthMeGetResponse> => {
  
  return customFetch<getCurrentAccountAuthMeGetResponse>(getGetCurrentAccountAuthMeGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


