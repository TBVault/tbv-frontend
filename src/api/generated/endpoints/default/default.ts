/**
 * Generated by orval v7.17.0 ðŸº
 * Do not edit manually.
 * The Bhakti Vault API
 * FastAPI application with OpenID Connect authentication
 * OpenAPI spec version: 1.0.0
 */
import type {
  ChatSession,
  ChatSessionHistoryResponse,
  HTTPValidationError,
  HelloDto,
  LoginResponse,
  NewMessageRequest,
  PublicHelloWorldPydanticPublicHelloWorldPydanticGetParams,
  SearchFromTranscriptsProtectedSearchTranscriptsGetParams,
  Transcript,
  TranscriptProtectedTranscriptGetParams,
  TranscriptSearchResultsPaginated,
  TranscriptsPaginated,
  TranscriptsProtectedTranscriptsGetParams,
  User
} from '../../schemas';

import { customFetch } from '../../../customFetch';

/**
 * Root endpoint
 * @summary Root
 */
export type rootGetResponse200 = {
  data: unknown
  status: 200
}
    
export type rootGetResponseSuccess = (rootGetResponse200) & {
  headers: Headers;
};
;

export type rootGetResponse = (rootGetResponseSuccess)

export const getRootGetUrl = () => {


  

  return `/`
}

export const rootGet = async ( options?: RequestInit): Promise<rootGetResponse> => {
  
  return customFetch<rootGetResponse>(getRootGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * Health check endpoint
 * @summary Health
 */
export type healthHealthGetResponse200 = {
  data: unknown
  status: 200
}
    
export type healthHealthGetResponseSuccess = (healthHealthGetResponse200) & {
  headers: Headers;
};
;

export type healthHealthGetResponse = (healthHealthGetResponseSuccess)

export const getHealthHealthGetUrl = () => {


  

  return `/health`
}

export const healthHealthGet = async ( options?: RequestInit): Promise<healthHealthGetResponse> => {
  
  return customFetch<healthHealthGetResponse>(getHealthHealthGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * @summary Public Hello World Pydantic
 */
export type publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse200 = {
  data: HelloDto
  status: 200
}

export type publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type publicHelloWorldPydanticPublicHelloWorldPydanticGetResponseSuccess = (publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse200) & {
  headers: Headers;
};
export type publicHelloWorldPydanticPublicHelloWorldPydanticGetResponseError = (publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse422) & {
  headers: Headers;
};

export type publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse = (publicHelloWorldPydanticPublicHelloWorldPydanticGetResponseSuccess | publicHelloWorldPydanticPublicHelloWorldPydanticGetResponseError)

export const getPublicHelloWorldPydanticPublicHelloWorldPydanticGetUrl = (params: PublicHelloWorldPydanticPublicHelloWorldPydanticGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/public/hello_world_pydantic?${stringifiedParams}` : `/public/hello_world_pydantic`
}

export const publicHelloWorldPydanticPublicHelloWorldPydanticGet = async (params: PublicHelloWorldPydanticPublicHelloWorldPydanticGetParams, options?: RequestInit): Promise<publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse> => {
  
  return customFetch<publicHelloWorldPydanticPublicHelloWorldPydanticGetResponse>(getPublicHelloWorldPydanticPublicHelloWorldPydanticGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * Protected hello world endpoint - requires valid OIDC JWT token.
Returns "helloworld" string.
 * @summary Protected Hello World
 */
export type protectedHelloWorldProtectedHelloworldGetResponse200 = {
  data: HelloDto
  status: 200
}
    
export type protectedHelloWorldProtectedHelloworldGetResponseSuccess = (protectedHelloWorldProtectedHelloworldGetResponse200) & {
  headers: Headers;
};
;

export type protectedHelloWorldProtectedHelloworldGetResponse = (protectedHelloWorldProtectedHelloworldGetResponseSuccess)

export const getProtectedHelloWorldProtectedHelloworldGetUrl = () => {


  

  return `/protected/helloworld`
}

export const protectedHelloWorldProtectedHelloworldGet = async ( options?: RequestInit): Promise<protectedHelloWorldProtectedHelloworldGetResponse> => {
  
  return customFetch<protectedHelloWorldProtectedHelloworldGetResponse>(getProtectedHelloWorldProtectedHelloworldGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * @summary Transcript
 */
export type transcriptProtectedTranscriptGetResponse200 = {
  data: Transcript
  status: 200
}

export type transcriptProtectedTranscriptGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type transcriptProtectedTranscriptGetResponseSuccess = (transcriptProtectedTranscriptGetResponse200) & {
  headers: Headers;
};
export type transcriptProtectedTranscriptGetResponseError = (transcriptProtectedTranscriptGetResponse422) & {
  headers: Headers;
};

export type transcriptProtectedTranscriptGetResponse = (transcriptProtectedTranscriptGetResponseSuccess | transcriptProtectedTranscriptGetResponseError)

export const getTranscriptProtectedTranscriptGetUrl = (params: TranscriptProtectedTranscriptGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/protected/transcript?${stringifiedParams}` : `/protected/transcript`
}

export const transcriptProtectedTranscriptGet = async (params: TranscriptProtectedTranscriptGetParams, options?: RequestInit): Promise<transcriptProtectedTranscriptGetResponse> => {
  
  return customFetch<transcriptProtectedTranscriptGetResponse>(getTranscriptProtectedTranscriptGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * @summary Transcripts
 */
export type transcriptsProtectedTranscriptsGetResponse200 = {
  data: TranscriptsPaginated
  status: 200
}

export type transcriptsProtectedTranscriptsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type transcriptsProtectedTranscriptsGetResponseSuccess = (transcriptsProtectedTranscriptsGetResponse200) & {
  headers: Headers;
};
export type transcriptsProtectedTranscriptsGetResponseError = (transcriptsProtectedTranscriptsGetResponse422) & {
  headers: Headers;
};

export type transcriptsProtectedTranscriptsGetResponse = (transcriptsProtectedTranscriptsGetResponseSuccess | transcriptsProtectedTranscriptsGetResponseError)

export const getTranscriptsProtectedTranscriptsGetUrl = (params: TranscriptsProtectedTranscriptsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/protected/transcripts?${stringifiedParams}` : `/protected/transcripts`
}

export const transcriptsProtectedTranscriptsGet = async (params: TranscriptsProtectedTranscriptsGetParams, options?: RequestInit): Promise<transcriptsProtectedTranscriptsGetResponse> => {
  
  return customFetch<transcriptsProtectedTranscriptsGetResponse>(getTranscriptsProtectedTranscriptsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * @summary Chat Session
 */
export type chatSessionProtectedCreateChatSessionPostResponse200 = {
  data: ChatSession
  status: 200
}
    
export type chatSessionProtectedCreateChatSessionPostResponseSuccess = (chatSessionProtectedCreateChatSessionPostResponse200) & {
  headers: Headers;
};
;

export type chatSessionProtectedCreateChatSessionPostResponse = (chatSessionProtectedCreateChatSessionPostResponseSuccess)

export const getChatSessionProtectedCreateChatSessionPostUrl = () => {


  

  return `/protected/create_chat_session`
}

export const chatSessionProtectedCreateChatSessionPost = async ( options?: RequestInit): Promise<chatSessionProtectedCreateChatSessionPostResponse> => {
  
  return customFetch<chatSessionProtectedCreateChatSessionPostResponse>(getChatSessionProtectedCreateChatSessionPostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}


/**
 * @summary Chat Sessions
 */
export type chatSessionsProtectedChatSessionsGetResponse200 = {
  data: ChatSession[]
  status: 200
}
    
export type chatSessionsProtectedChatSessionsGetResponseSuccess = (chatSessionsProtectedChatSessionsGetResponse200) & {
  headers: Headers;
};
;

export type chatSessionsProtectedChatSessionsGetResponse = (chatSessionsProtectedChatSessionsGetResponseSuccess)

export const getChatSessionsProtectedChatSessionsGetUrl = () => {


  

  return `/protected/chat_sessions`
}

export const chatSessionsProtectedChatSessionsGet = async ( options?: RequestInit): Promise<chatSessionsProtectedChatSessionsGetResponse> => {
  
  return customFetch<chatSessionsProtectedChatSessionsGetResponse>(getChatSessionsProtectedChatSessionsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * @summary Chat Session History
 */
export type chatSessionHistoryProtectedChatSessionChatSessionIdGetResponse200 = {
  data: ChatSessionHistoryResponse
  status: 200
}

export type chatSessionHistoryProtectedChatSessionChatSessionIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type chatSessionHistoryProtectedChatSessionChatSessionIdGetResponseSuccess = (chatSessionHistoryProtectedChatSessionChatSessionIdGetResponse200) & {
  headers: Headers;
};
export type chatSessionHistoryProtectedChatSessionChatSessionIdGetResponseError = (chatSessionHistoryProtectedChatSessionChatSessionIdGetResponse422) & {
  headers: Headers;
};

export type chatSessionHistoryProtectedChatSessionChatSessionIdGetResponse = (chatSessionHistoryProtectedChatSessionChatSessionIdGetResponseSuccess | chatSessionHistoryProtectedChatSessionChatSessionIdGetResponseError)

export const getChatSessionHistoryProtectedChatSessionChatSessionIdGetUrl = (chatSessionId: string,) => {


  

  return `/protected/chat_session/${chatSessionId}`
}

export const chatSessionHistoryProtectedChatSessionChatSessionIdGet = async (chatSessionId: string, options?: RequestInit): Promise<chatSessionHistoryProtectedChatSessionChatSessionIdGetResponse> => {
  
  return customFetch<chatSessionHistoryProtectedChatSessionChatSessionIdGetResponse>(getChatSessionHistoryProtectedChatSessionChatSessionIdGetUrl(chatSessionId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * @summary New Message
 */
export type newMessageProtectedChatSessionChatSessionIdNewMessagePostResponse200 = {
  data: unknown
  status: 200
}

export type newMessageProtectedChatSessionChatSessionIdNewMessagePostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type newMessageProtectedChatSessionChatSessionIdNewMessagePostResponseSuccess = (newMessageProtectedChatSessionChatSessionIdNewMessagePostResponse200) & {
  headers: Headers;
};
export type newMessageProtectedChatSessionChatSessionIdNewMessagePostResponseError = (newMessageProtectedChatSessionChatSessionIdNewMessagePostResponse422) & {
  headers: Headers;
};

export type newMessageProtectedChatSessionChatSessionIdNewMessagePostResponse = (newMessageProtectedChatSessionChatSessionIdNewMessagePostResponseSuccess | newMessageProtectedChatSessionChatSessionIdNewMessagePostResponseError)

export const getNewMessageProtectedChatSessionChatSessionIdNewMessagePostUrl = (chatSessionId: string,) => {


  

  return `/protected/chat_session/${chatSessionId}/new_message`
}

export const newMessageProtectedChatSessionChatSessionIdNewMessagePost = async (chatSessionId: string,
    newMessageRequest: NewMessageRequest, options?: RequestInit): Promise<newMessageProtectedChatSessionChatSessionIdNewMessagePostResponse> => {
  
  return customFetch<newMessageProtectedChatSessionChatSessionIdNewMessagePostResponse>(getNewMessageProtectedChatSessionChatSessionIdNewMessagePostUrl(chatSessionId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      newMessageRequest,)
  }
);}


/**
 * @summary Search From Transcripts
 */
export type searchFromTranscriptsProtectedSearchTranscriptsGetResponse200 = {
  data: TranscriptSearchResultsPaginated
  status: 200
}

export type searchFromTranscriptsProtectedSearchTranscriptsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type searchFromTranscriptsProtectedSearchTranscriptsGetResponseSuccess = (searchFromTranscriptsProtectedSearchTranscriptsGetResponse200) & {
  headers: Headers;
};
export type searchFromTranscriptsProtectedSearchTranscriptsGetResponseError = (searchFromTranscriptsProtectedSearchTranscriptsGetResponse422) & {
  headers: Headers;
};

export type searchFromTranscriptsProtectedSearchTranscriptsGetResponse = (searchFromTranscriptsProtectedSearchTranscriptsGetResponseSuccess | searchFromTranscriptsProtectedSearchTranscriptsGetResponseError)

export const getSearchFromTranscriptsProtectedSearchTranscriptsGetUrl = (params: SearchFromTranscriptsProtectedSearchTranscriptsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/protected/search/transcripts?${stringifiedParams}` : `/protected/search/transcripts`
}

export const searchFromTranscriptsProtectedSearchTranscriptsGet = async (params: SearchFromTranscriptsProtectedSearchTranscriptsGetParams, options?: RequestInit): Promise<searchFromTranscriptsProtectedSearchTranscriptsGetResponse> => {
  
  return customFetch<searchFromTranscriptsProtectedSearchTranscriptsGetResponse>(getSearchFromTranscriptsProtectedSearchTranscriptsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * Login endpoint - validates OIDC JWT token and returns user information.
Send the Google OIDC token in the Authorization header as: Bearer <token>
Returns a failed login response if the user doesn't exist in the database.
 * @summary Login
 */
export type loginAuthLoginPostResponse200 = {
  data: LoginResponse
  status: 200
}
    
export type loginAuthLoginPostResponseSuccess = (loginAuthLoginPostResponse200) & {
  headers: Headers;
};
;

export type loginAuthLoginPostResponse = (loginAuthLoginPostResponseSuccess)

export const getLoginAuthLoginPostUrl = () => {


  

  return `/auth/login`
}

export const loginAuthLoginPost = async ( options?: RequestInit): Promise<loginAuthLoginPostResponse> => {
  
  return customFetch<loginAuthLoginPostResponse>(getLoginAuthLoginPostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}


/**
 * Get the current authenticated user's account information.
Requires a valid OIDC JWT token.
 * @summary Get Current Account
 */
export type getCurrentAccountAuthMeGetResponse200 = {
  data: User
  status: 200
}
    
export type getCurrentAccountAuthMeGetResponseSuccess = (getCurrentAccountAuthMeGetResponse200) & {
  headers: Headers;
};
;

export type getCurrentAccountAuthMeGetResponse = (getCurrentAccountAuthMeGetResponseSuccess)

export const getGetCurrentAccountAuthMeGetUrl = () => {


  

  return `/auth/me`
}

export const getCurrentAccountAuthMeGet = async ( options?: RequestInit): Promise<getCurrentAccountAuthMeGetResponse> => {
  
  return customFetch<getCurrentAccountAuthMeGetResponse>(getGetCurrentAccountAuthMeGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


